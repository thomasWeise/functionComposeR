% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compose.R
\name{function.compose}
\alias{function.compose}
\title{Concatenate Two Functions}
\usage{
function.compose(f, g, f2g = "x")
}
\arguments{
\item{f}{the inner function}

\item{g}{the outer function}

\item{f2g}{the argument of \code{g} to be replaced with the return value of \code{f}}
}
\description{
Try to find a small and efficient representation of the
concatenation of to functions \code{f} and \code{g} such that the resulting
function has the form \code{h(...)=g(...,f(...),...)} (where \code{...} stands
for an arbitrary numer of arguments, not the \code{R}-style dots).

More precisely: The input are two functions \code{f} and \code{g} and a
"bridge argument" \code{f2g}. Both functions may have an arbirary argument
list, say \code{f(x,y,z=7,c)} and \code{g(a=3,b=4,c)}. The "bridge argument"
can be any parameter of \code{g}, let's say \code{b}. The result of
\code{function.compose(f, g, f2g="b")} will then be a function
\code{h(a=3,c,x,y,z=7)} which is equivalent to \code{g(a, f(x, y, z, c), c)}.

Since we also canonicalize all functions (\code{f}, \code{g}, and \code{h})
involved, this means also that we attempt to substitute all potentially
substitutable variables and simplify the inner expressions as much as
possible.

This is particularly useful when iteratively composing functions and wanting
to retain their readability and making the result as fast to execute as
possible. However, the behavior may be undefined if the parameters of the
function can be resolved as constant values in the current environment or
if functions with otherwise odd parameters are successfively composed.

If the result of \code{f} is used exactly once in \code{g}, we substitute
the body of \code{f} into \code{g} to directly replace the bridge parameter.
If it is used more than once, we first shovel its result into a variable,
namely the bridge parameter.

As example, assume you have set \code{k <- 23} and now want to compose the
functions \code{f<-function(x) { (k*x) + 7 }} and \code{g<-function(x) {
(k*k-x*x) / (x - sin(k)) }} to a function \code{h}. You can do that by
writing \code{h<-function(x) g(f(x))}. Of course, if you later try to inspect
\code{h} and just write \code{h}, you will see exactly this,
\code{function(x) g(f(x))}. This leads to two issues: First, if you do not
know \code{f} and \code{g}, the output is meaningless and opaque, you cannot
interpret it. Second, evaluating \code{h} is unnecessarily slow: It performs
two inner function calls and needs to evaluate a variable \code{k} at several
locations, although the value of \code{k} should be fixed to \code{23}.
Matter of fact, also \code{k*k} and \code{sin(k)} are constants which could
be known.

The goal of \code{function.compose} is to resolve these two issues. If you do
\code{h<-function.compose(f, g)} instead of \code{h<-function(x) g(f(x))}, a
new function composed of both the bodies of \code{f} and \code{g} is created.
Furthermore, as many of the variables and expressions in the body which can
be resolved as possible are replaced by their constant result. Printing the
result of \code{h<-function.compose(f, g)} would yield (something like)
\code{function (x) { x <- (23 * x) + 7; (529 - x * x)/(x -
-0.846220404175171) }}.
}
\examples{
f<-function(x,y,z=7,c) { x+23*y-z+2+c }
g<-function(a=3,b=4,c) { a*b - b*c }
function.compose(f, g, f2g="b")
# function (a = 3, c, x, y, z = 7)
# {
#   b <- x + 23 * y - z + 2 + c
#   a * b - b * c
# }
function.compose(sin, cos, f2g="x")
# function (x)
# cos(x = sin(x = x))
k <- 23
f2 <- function(x) { k*5 + x }
g2 <- function(x) { x/(k - sin(k)) }
function.compose(f2, g2)
# function (x)
# (115 + x)/23.8462204041752
k<-23
f<-function(x) { (k*x) + 7 }
g<-function(x) { (k*k-x*x) / (x - sin(k)) }
h.plain<-function(x) g(f(x))
h.plain
# function(x) g(f(x))
h.composed<-function.compose(f, g)
h.composed
# function (x)
# {
#   x <- (23 * x) + 7
#   (529 - x * x)/(x - -0.846220404175171)
# }
i<-45
j<-33
k<-23
f <- function(x) { (x*(x-i)) - x/sinh(k*cos(j-atan(k+j))) }
g <- function(x) { abs(x)^(abs(1/(3-i))) + (j - k*exp(-i)) / ((i*j) * x) }
h.1.plain <- function(x) g(f(x))
h.1.plain
# function(x) g(f(x))
h.1.composed <- function.compose(f, g)
h.1.composed
# function (x)
# {
#     x <- (x * (x - 45)) - x/4818399372.40284
#     abs(x)^0.0238095238095238 + 33/(1485 * x)
# }
h.2.plain <- function(x) g(f(g(f(x))))
h.2.plain
# function(x) g(f(g(f(x))))
h.2.composed <- function.compose(function.compose(function.compose(f, g), f), g)
h.2.composed
# function (x)
# {
#     x <- {
#         x <- {
#             x <- (x * (x - 45)) - x/4818399372.40284
#             abs(x)^0.0238095238095238 + 33/(1485 * x)
#         }
#         (x * (x - 45)) - x/4818399372.40284
#     }
#     abs(x)^0.0238095238095238 + 33/(1485 * x)
# }
x <- runif(1000)
library(microbenchmark)
microbenchmark(h.1.plain(x), h.1.composed(x), h.2.plain(x), h.2.composed(x))
# Unit: microseconds
#             expr     min       lq      mean   median       uq     max neval
#     h.1.plain(x)  78.841  79.4880  83.05224  79.9775  85.8485 119.824   100
#  h.1.composed(x)  75.890  76.4675  93.23504  76.8385  78.9615 896.681   100
#     h.2.plain(x) 153.793 154.8100 166.31210 155.5855 164.3685 743.360   100
#  h.2.composed(x) 149.035 149.4870 155.25070 149.8895 154.0960 213.395   100
}
